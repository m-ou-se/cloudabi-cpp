// Copyright (c) 2016 Nuxi (https://nuxi.nl/) and contributors.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// This file is automatically generated. Do not edit.
//
// Source: https://github.com/NuxiNL/cloudabi

#ifndef CLOUDABI_RAW_HPP
#define CLOUDABI_RAW_HPP

#include <cloudabi_types_common.h>

namespace cloudabi {
namespace raw {

enum class advice : cloudabi_advice_t {
  dontneed   = CLOUDABI_ADVICE_DONTNEED,
  noreuse    = CLOUDABI_ADVICE_NOREUSE,
  normal     = CLOUDABI_ADVICE_NORMAL,
  random     = CLOUDABI_ADVICE_RANDOM,
  sequential = CLOUDABI_ADVICE_SEQUENTIAL,
  willneed   = CLOUDABI_ADVICE_WILLNEED,
};

enum class auxtype : cloudabi_auxtype_t {
  argdata      = CLOUDABI_AT_ARGDATA,
  argdatalen   = CLOUDABI_AT_ARGDATALEN,
  base         = CLOUDABI_AT_BASE,
  canary       = CLOUDABI_AT_CANARY,
  canarylen    = CLOUDABI_AT_CANARYLEN,
  ncpus        = CLOUDABI_AT_NCPUS,
  null         = CLOUDABI_AT_NULL,
  pagesz       = CLOUDABI_AT_PAGESZ,
  phdr         = CLOUDABI_AT_PHDR,
  phnum        = CLOUDABI_AT_PHNUM,
  sysinfo_ehdr = CLOUDABI_AT_SYSINFO_EHDR,
  tid          = CLOUDABI_AT_TID,
};

using backlog = cloudabi_backlog_t;

enum class clockid : cloudabi_clockid_t {
  monotonic          = CLOUDABI_CLOCK_MONOTONIC,
  process_cputime_id = CLOUDABI_CLOCK_PROCESS_CPUTIME_ID,
  realtime           = CLOUDABI_CLOCK_REALTIME,
  thread_cputime_id  = CLOUDABI_CLOCK_THREAD_CPUTIME_ID,
};

enum class condvar : cloudabi_condvar_t {
  has_no_waiters = CLOUDABI_CONDVAR_HAS_NO_WAITERS,
};

enum class device : cloudabi_device_t {};

enum class dircookie : cloudabi_dircookie_t {
  start = CLOUDABI_DIRCOOKIE_START,
};

enum class errno : cloudabi_errno_t {
  _2big          = CLOUDABI_E2BIG,
  acces          = CLOUDABI_EACCES,
  addrinuse      = CLOUDABI_EADDRINUSE,
  addrnotavail   = CLOUDABI_EADDRNOTAVAIL,
  afnosupport    = CLOUDABI_EAFNOSUPPORT,
  again          = CLOUDABI_EAGAIN,
  already        = CLOUDABI_EALREADY,
  badf           = CLOUDABI_EBADF,
  badmsg         = CLOUDABI_EBADMSG,
  busy           = CLOUDABI_EBUSY,
  canceled       = CLOUDABI_ECANCELED,
  child          = CLOUDABI_ECHILD,
  connaborted    = CLOUDABI_ECONNABORTED,
  connrefused    = CLOUDABI_ECONNREFUSED,
  connreset      = CLOUDABI_ECONNRESET,
  deadlk         = CLOUDABI_EDEADLK,
  destaddrreq    = CLOUDABI_EDESTADDRREQ,
  dom            = CLOUDABI_EDOM,
  dquot          = CLOUDABI_EDQUOT,
  exist          = CLOUDABI_EEXIST,
  fault          = CLOUDABI_EFAULT,
  fbig           = CLOUDABI_EFBIG,
  hostunreach    = CLOUDABI_EHOSTUNREACH,
  idrm           = CLOUDABI_EIDRM,
  ilseq          = CLOUDABI_EILSEQ,
  inprogress     = CLOUDABI_EINPROGRESS,
  intr           = CLOUDABI_EINTR,
  inval          = CLOUDABI_EINVAL,
  io             = CLOUDABI_EIO,
  isconn         = CLOUDABI_EISCONN,
  isdir          = CLOUDABI_EISDIR,
  loop           = CLOUDABI_ELOOP,
  mfile          = CLOUDABI_EMFILE,
  mlink          = CLOUDABI_EMLINK,
  msgsize        = CLOUDABI_EMSGSIZE,
  multihop       = CLOUDABI_EMULTIHOP,
  nametoolong    = CLOUDABI_ENAMETOOLONG,
  netdown        = CLOUDABI_ENETDOWN,
  netreset       = CLOUDABI_ENETRESET,
  netunreach     = CLOUDABI_ENETUNREACH,
  nfile          = CLOUDABI_ENFILE,
  nobufs         = CLOUDABI_ENOBUFS,
  nodev          = CLOUDABI_ENODEV,
  noent          = CLOUDABI_ENOENT,
  noexec         = CLOUDABI_ENOEXEC,
  nolck          = CLOUDABI_ENOLCK,
  nolink         = CLOUDABI_ENOLINK,
  nomem          = CLOUDABI_ENOMEM,
  nomsg          = CLOUDABI_ENOMSG,
  noprotoopt     = CLOUDABI_ENOPROTOOPT,
  nospc          = CLOUDABI_ENOSPC,
  nosys          = CLOUDABI_ENOSYS,
  notconn        = CLOUDABI_ENOTCONN,
  notdir         = CLOUDABI_ENOTDIR,
  notempty       = CLOUDABI_ENOTEMPTY,
  notrecoverable = CLOUDABI_ENOTRECOVERABLE,
  notsock        = CLOUDABI_ENOTSOCK,
  notsup         = CLOUDABI_ENOTSUP,
  notty          = CLOUDABI_ENOTTY,
  nxio           = CLOUDABI_ENXIO,
  overflow       = CLOUDABI_EOVERFLOW,
  ownerdead      = CLOUDABI_EOWNERDEAD,
  perm           = CLOUDABI_EPERM,
  pipe           = CLOUDABI_EPIPE,
  proto          = CLOUDABI_EPROTO,
  protonosupport = CLOUDABI_EPROTONOSUPPORT,
  prototype      = CLOUDABI_EPROTOTYPE,
  range          = CLOUDABI_ERANGE,
  rofs           = CLOUDABI_EROFS,
  spipe          = CLOUDABI_ESPIPE,
  srch           = CLOUDABI_ESRCH,
  stale          = CLOUDABI_ESTALE,
  timedout       = CLOUDABI_ETIMEDOUT,
  txtbsy         = CLOUDABI_ETXTBSY,
  xdev           = CLOUDABI_EXDEV,
  notcapable     = CLOUDABI_ENOTCAPABLE,
};

enum class eventrwflags : cloudabi_eventrwflags_t {
  none   = 0,
  hangup = CLOUDABI_EVENT_FD_READWRITE_HANGUP,
};

inline eventrwflags operator | (eventrwflags a, eventrwflags b) {
  return eventrwflags(cloudabi_eventrwflags_t(a) | cloudabi_eventrwflags_t(b));
}

inline eventrwflags operator & (eventrwflags a, eventrwflags b) {
  return eventrwflags(cloudabi_eventrwflags_t(a) & cloudabi_eventrwflags_t(b));
}

inline eventrwflags operator ~ (eventrwflags v) {
  return eventrwflags(~cloudabi_eventrwflags_t(v));
}

enum class eventtype : cloudabi_eventtype_t {
  clock          = CLOUDABI_EVENTTYPE_CLOCK,
  condvar        = CLOUDABI_EVENTTYPE_CONDVAR,
  fd_read        = CLOUDABI_EVENTTYPE_FD_READ,
  fd_write       = CLOUDABI_EVENTTYPE_FD_WRITE,
  lock_rdlock    = CLOUDABI_EVENTTYPE_LOCK_RDLOCK,
  lock_wrlock    = CLOUDABI_EVENTTYPE_LOCK_WRLOCK,
  proc_terminate = CLOUDABI_EVENTTYPE_PROC_TERMINATE,
};

using exitcode = cloudabi_exitcode_t;

enum class fd : cloudabi_fd_t {
  process_child = CLOUDABI_PROCESS_CHILD,
  map_anon_fd   = CLOUDABI_MAP_ANON_FD,
};

enum class fdflags : cloudabi_fdflags_t {
  none     = 0,
  append   = CLOUDABI_FDFLAG_APPEND,
  dsync    = CLOUDABI_FDFLAG_DSYNC,
  nonblock = CLOUDABI_FDFLAG_NONBLOCK,
  rsync    = CLOUDABI_FDFLAG_RSYNC,
  sync     = CLOUDABI_FDFLAG_SYNC,
};

inline fdflags operator | (fdflags a, fdflags b) {
  return fdflags(cloudabi_fdflags_t(a) | cloudabi_fdflags_t(b));
}

inline fdflags operator & (fdflags a, fdflags b) {
  return fdflags(cloudabi_fdflags_t(a) & cloudabi_fdflags_t(b));
}

inline fdflags operator ~ (fdflags v) {
  return fdflags(~cloudabi_fdflags_t(v));
}

enum class fdsflags : cloudabi_fdsflags_t {
  none   = 0,
  flags  = CLOUDABI_FDSTAT_FLAGS,
  rights = CLOUDABI_FDSTAT_RIGHTS,
};

inline fdsflags operator | (fdsflags a, fdsflags b) {
  return fdsflags(cloudabi_fdsflags_t(a) | cloudabi_fdsflags_t(b));
}

inline fdsflags operator & (fdsflags a, fdsflags b) {
  return fdsflags(cloudabi_fdsflags_t(a) & cloudabi_fdsflags_t(b));
}

inline fdsflags operator ~ (fdsflags v) {
  return fdsflags(~cloudabi_fdsflags_t(v));
}

using filedelta = cloudabi_filedelta_t;

using filesize = cloudabi_filesize_t;

enum class filetype : cloudabi_filetype_t {
  unknown          = CLOUDABI_FILETYPE_UNKNOWN,
  block_device     = CLOUDABI_FILETYPE_BLOCK_DEVICE,
  character_device = CLOUDABI_FILETYPE_CHARACTER_DEVICE,
  directory        = CLOUDABI_FILETYPE_DIRECTORY,
  fifo             = CLOUDABI_FILETYPE_FIFO,
  poll             = CLOUDABI_FILETYPE_POLL,
  process          = CLOUDABI_FILETYPE_PROCESS,
  regular_file     = CLOUDABI_FILETYPE_REGULAR_FILE,
  shared_memory    = CLOUDABI_FILETYPE_SHARED_MEMORY,
  socket_dgram     = CLOUDABI_FILETYPE_SOCKET_DGRAM,
  socket_seqpacket = CLOUDABI_FILETYPE_SOCKET_SEQPACKET,
  socket_stream    = CLOUDABI_FILETYPE_SOCKET_STREAM,
  symbolic_link    = CLOUDABI_FILETYPE_SYMBOLIC_LINK,
};

enum class fsflags : cloudabi_fsflags_t {
  none     = 0,
  atim     = CLOUDABI_FILESTAT_ATIM,
  atim_now = CLOUDABI_FILESTAT_ATIM_NOW,
  mtim     = CLOUDABI_FILESTAT_MTIM,
  mtim_now = CLOUDABI_FILESTAT_MTIM_NOW,
  size     = CLOUDABI_FILESTAT_SIZE,
};

inline fsflags operator | (fsflags a, fsflags b) {
  return fsflags(cloudabi_fsflags_t(a) | cloudabi_fsflags_t(b));
}

inline fsflags operator & (fsflags a, fsflags b) {
  return fsflags(cloudabi_fsflags_t(a) & cloudabi_fsflags_t(b));
}

inline fsflags operator ~ (fsflags v) {
  return fsflags(~cloudabi_fsflags_t(v));
}

enum class inode : cloudabi_inode_t {};

using linkcount = cloudabi_linkcount_t;

enum class lock : cloudabi_lock_t {
  unlocked       = CLOUDABI_LOCK_UNLOCKED,
  wrlocked       = CLOUDABI_LOCK_WRLOCKED,
  kernel_managed = CLOUDABI_LOCK_KERNEL_MANAGED,
  bogus          = CLOUDABI_LOCK_BOGUS,
};

enum class lookupflags : cloudabi_lookupflags_t {
  none           = 0,
  symlink_follow = CLOUDABI_LOOKUP_SYMLINK_FOLLOW,
};

inline lookupflags operator | (lookupflags a, lookupflags b) {
  return lookupflags(cloudabi_lookupflags_t(a) | cloudabi_lookupflags_t(b));
}

inline lookupflags operator & (lookupflags a, lookupflags b) {
  return lookupflags(cloudabi_lookupflags_t(a) & cloudabi_lookupflags_t(b));
}

inline lookupflags operator ~ (lookupflags v) {
  return lookupflags(~cloudabi_lookupflags_t(v));
}

enum class mflags : cloudabi_mflags_t {
  none     = 0,
  anon     = CLOUDABI_MAP_ANON,
  fixed    = CLOUDABI_MAP_FIXED,
  private_ = CLOUDABI_MAP_PRIVATE,
  shared   = CLOUDABI_MAP_SHARED,
};

inline mflags operator | (mflags a, mflags b) {
  return mflags(cloudabi_mflags_t(a) | cloudabi_mflags_t(b));
}

inline mflags operator & (mflags a, mflags b) {
  return mflags(cloudabi_mflags_t(a) & cloudabi_mflags_t(b));
}

inline mflags operator ~ (mflags v) {
  return mflags(~cloudabi_mflags_t(v));
}

enum class mprot : cloudabi_mprot_t {
  none  = 0,
  exec  = CLOUDABI_PROT_EXEC,
  write = CLOUDABI_PROT_WRITE,
  read  = CLOUDABI_PROT_READ,
};

inline mprot operator | (mprot a, mprot b) {
  return mprot(cloudabi_mprot_t(a) | cloudabi_mprot_t(b));
}

inline mprot operator & (mprot a, mprot b) {
  return mprot(cloudabi_mprot_t(a) & cloudabi_mprot_t(b));
}

inline mprot operator ~ (mprot v) {
  return mprot(~cloudabi_mprot_t(v));
}

enum class msflags : cloudabi_msflags_t {
  none       = 0,
  async      = CLOUDABI_MS_ASYNC,
  invalidate = CLOUDABI_MS_INVALIDATE,
  sync       = CLOUDABI_MS_SYNC,
};

inline msflags operator | (msflags a, msflags b) {
  return msflags(cloudabi_msflags_t(a) | cloudabi_msflags_t(b));
}

inline msflags operator & (msflags a, msflags b) {
  return msflags(cloudabi_msflags_t(a) & cloudabi_msflags_t(b));
}

inline msflags operator ~ (msflags v) {
  return msflags(~cloudabi_msflags_t(v));
}

enum class msgflags : cloudabi_msgflags_t {
  none    = 0,
  ctrunc  = CLOUDABI_MSG_CTRUNC,
  eor     = CLOUDABI_MSG_EOR,
  peek    = CLOUDABI_MSG_PEEK,
  trunc   = CLOUDABI_MSG_TRUNC,
  waitall = CLOUDABI_MSG_WAITALL,
};

inline msgflags operator | (msgflags a, msgflags b) {
  return msgflags(cloudabi_msgflags_t(a) | cloudabi_msgflags_t(b));
}

inline msgflags operator & (msgflags a, msgflags b) {
  return msgflags(cloudabi_msgflags_t(a) & cloudabi_msgflags_t(b));
}

inline msgflags operator ~ (msgflags v) {
  return msgflags(~cloudabi_msgflags_t(v));
}

using nthreads = cloudabi_nthreads_t;

enum class oflags : cloudabi_oflags_t {
  none      = 0,
  creat     = CLOUDABI_O_CREAT,
  directory = CLOUDABI_O_DIRECTORY,
  excl      = CLOUDABI_O_EXCL,
  trunc     = CLOUDABI_O_TRUNC,
};

inline oflags operator | (oflags a, oflags b) {
  return oflags(cloudabi_oflags_t(a) | cloudabi_oflags_t(b));
}

inline oflags operator & (oflags a, oflags b) {
  return oflags(cloudabi_oflags_t(a) & cloudabi_oflags_t(b));
}

inline oflags operator ~ (oflags v) {
  return oflags(~cloudabi_oflags_t(v));
}

enum class rights : cloudabi_rights_t {
  none                   = 0,
  fd_datasync            = CLOUDABI_RIGHT_FD_DATASYNC,
  fd_read                = CLOUDABI_RIGHT_FD_READ,
  fd_seek                = CLOUDABI_RIGHT_FD_SEEK,
  fd_stat_put_flags      = CLOUDABI_RIGHT_FD_STAT_PUT_FLAGS,
  fd_sync                = CLOUDABI_RIGHT_FD_SYNC,
  fd_tell                = CLOUDABI_RIGHT_FD_TELL,
  fd_write               = CLOUDABI_RIGHT_FD_WRITE,
  file_advise            = CLOUDABI_RIGHT_FILE_ADVISE,
  file_allocate          = CLOUDABI_RIGHT_FILE_ALLOCATE,
  file_create_directory  = CLOUDABI_RIGHT_FILE_CREATE_DIRECTORY,
  file_create_file       = CLOUDABI_RIGHT_FILE_CREATE_FILE,
  file_create_fifo       = CLOUDABI_RIGHT_FILE_CREATE_FIFO,
  file_link_source       = CLOUDABI_RIGHT_FILE_LINK_SOURCE,
  file_link_target       = CLOUDABI_RIGHT_FILE_LINK_TARGET,
  file_open              = CLOUDABI_RIGHT_FILE_OPEN,
  file_readdir           = CLOUDABI_RIGHT_FILE_READDIR,
  file_readlink          = CLOUDABI_RIGHT_FILE_READLINK,
  file_rename_source     = CLOUDABI_RIGHT_FILE_RENAME_SOURCE,
  file_rename_target     = CLOUDABI_RIGHT_FILE_RENAME_TARGET,
  file_stat_fget         = CLOUDABI_RIGHT_FILE_STAT_FGET,
  file_stat_fput_size    = CLOUDABI_RIGHT_FILE_STAT_FPUT_SIZE,
  file_stat_fput_times   = CLOUDABI_RIGHT_FILE_STAT_FPUT_TIMES,
  file_stat_get          = CLOUDABI_RIGHT_FILE_STAT_GET,
  file_stat_put_times    = CLOUDABI_RIGHT_FILE_STAT_PUT_TIMES,
  file_symlink           = CLOUDABI_RIGHT_FILE_SYMLINK,
  file_unlink            = CLOUDABI_RIGHT_FILE_UNLINK,
  mem_map                = CLOUDABI_RIGHT_MEM_MAP,
  mem_map_exec           = CLOUDABI_RIGHT_MEM_MAP_EXEC,
  poll_fd_readwrite      = CLOUDABI_RIGHT_POLL_FD_READWRITE,
  poll_modify            = CLOUDABI_RIGHT_POLL_MODIFY,
  poll_proc_terminate    = CLOUDABI_RIGHT_POLL_PROC_TERMINATE,
  poll_wait              = CLOUDABI_RIGHT_POLL_WAIT,
  proc_exec              = CLOUDABI_RIGHT_PROC_EXEC,
  sock_accept            = CLOUDABI_RIGHT_SOCK_ACCEPT,
  sock_bind_directory    = CLOUDABI_RIGHT_SOCK_BIND_DIRECTORY,
  sock_bind_socket       = CLOUDABI_RIGHT_SOCK_BIND_SOCKET,
  sock_connect_directory = CLOUDABI_RIGHT_SOCK_CONNECT_DIRECTORY,
  sock_connect_socket    = CLOUDABI_RIGHT_SOCK_CONNECT_SOCKET,
  sock_listen            = CLOUDABI_RIGHT_SOCK_LISTEN,
  sock_shutdown          = CLOUDABI_RIGHT_SOCK_SHUTDOWN,
  sock_stat_get          = CLOUDABI_RIGHT_SOCK_STAT_GET,
};

inline rights operator | (rights a, rights b) {
  return rights(cloudabi_rights_t(a) | cloudabi_rights_t(b));
}

inline rights operator & (rights a, rights b) {
  return rights(cloudabi_rights_t(a) & cloudabi_rights_t(b));
}

inline rights operator ~ (rights v) {
  return rights(~cloudabi_rights_t(v));
}

enum class sa_family : cloudabi_sa_family_t {
  unspec = CLOUDABI_AF_UNSPEC,
  inet   = CLOUDABI_AF_INET,
  inet6  = CLOUDABI_AF_INET6,
  unix   = CLOUDABI_AF_UNIX,
};

enum class scope : cloudabi_scope_t {
  private_ = CLOUDABI_SCOPE_PRIVATE,
  shared   = CLOUDABI_SCOPE_SHARED,
};

enum class sdflags : cloudabi_sdflags_t {
  none = 0,
  rd = CLOUDABI_SHUT_RD,
  wr = CLOUDABI_SHUT_WR,
};

inline sdflags operator | (sdflags a, sdflags b) {
  return sdflags(cloudabi_sdflags_t(a) | cloudabi_sdflags_t(b));
}

inline sdflags operator & (sdflags a, sdflags b) {
  return sdflags(cloudabi_sdflags_t(a) & cloudabi_sdflags_t(b));
}

inline sdflags operator ~ (sdflags v) {
  return sdflags(~cloudabi_sdflags_t(v));
}

enum class signal : cloudabi_signal_t {
  abrt   = CLOUDABI_SIGABRT,
  alrm   = CLOUDABI_SIGALRM,
  bus    = CLOUDABI_SIGBUS,
  chld   = CLOUDABI_SIGCHLD,
  cont   = CLOUDABI_SIGCONT,
  fpe    = CLOUDABI_SIGFPE,
  hup    = CLOUDABI_SIGHUP,
  ill    = CLOUDABI_SIGILL,
  int_   = CLOUDABI_SIGINT,
  kill   = CLOUDABI_SIGKILL,
  pipe   = CLOUDABI_SIGPIPE,
  quit   = CLOUDABI_SIGQUIT,
  segv   = CLOUDABI_SIGSEGV,
  stop   = CLOUDABI_SIGSTOP,
  sys    = CLOUDABI_SIGSYS,
  term   = CLOUDABI_SIGTERM,
  trap   = CLOUDABI_SIGTRAP,
  tstp   = CLOUDABI_SIGTSTP,
  ttin   = CLOUDABI_SIGTTIN,
  ttou   = CLOUDABI_SIGTTOU,
  urg    = CLOUDABI_SIGURG,
  usr1   = CLOUDABI_SIGUSR1,
  usr2   = CLOUDABI_SIGUSR2,
  vtalrm = CLOUDABI_SIGVTALRM,
  xcpu   = CLOUDABI_SIGXCPU,
  xfsz   = CLOUDABI_SIGXFSZ,
};

enum class ssflags : cloudabi_ssflags_t {
  none        = 0,
  clear_error = CLOUDABI_SOCKSTAT_CLEAR_ERROR,
};

inline ssflags operator | (ssflags a, ssflags b) {
  return ssflags(cloudabi_ssflags_t(a) | cloudabi_ssflags_t(b));
}

inline ssflags operator & (ssflags a, ssflags b) {
  return ssflags(cloudabi_ssflags_t(a) & cloudabi_ssflags_t(b));
}

inline ssflags operator ~ (ssflags v) {
  return ssflags(~cloudabi_ssflags_t(v));
}

enum class sstate : cloudabi_sstate_t {
  none       = 0,
  acceptconn = CLOUDABI_SOCKSTATE_ACCEPTCONN,
};

inline sstate operator | (sstate a, sstate b) {
  return sstate(cloudabi_sstate_t(a) | cloudabi_sstate_t(b));
}

inline sstate operator & (sstate a, sstate b) {
  return sstate(cloudabi_sstate_t(a) & cloudabi_sstate_t(b));
}

inline sstate operator ~ (sstate v) {
  return sstate(~cloudabi_sstate_t(v));
}

enum class subclockflags : cloudabi_subclockflags_t {
  none    = 0,
  abstime = CLOUDABI_SUBSCRIPTION_CLOCK_ABSTIME,
};

inline subclockflags operator | (subclockflags a, subclockflags b) {
  return subclockflags(cloudabi_subclockflags_t(a) | cloudabi_subclockflags_t(b));
}

inline subclockflags operator & (subclockflags a, subclockflags b) {
  return subclockflags(cloudabi_subclockflags_t(a) & cloudabi_subclockflags_t(b));
}

inline subclockflags operator ~ (subclockflags v) {
  return subclockflags(~cloudabi_subclockflags_t(v));
}

enum class subflags : cloudabi_subflags_t {
  none    = 0,
  add     = CLOUDABI_SUBSCRIPTION_ADD,
  clear   = CLOUDABI_SUBSCRIPTION_CLEAR,
  delete_ = CLOUDABI_SUBSCRIPTION_DELETE,
  disable = CLOUDABI_SUBSCRIPTION_DISABLE,
  enable  = CLOUDABI_SUBSCRIPTION_ENABLE,
  oneshot = CLOUDABI_SUBSCRIPTION_ONESHOT,
};

inline subflags operator | (subflags a, subflags b) {
  return subflags(cloudabi_subflags_t(a) | cloudabi_subflags_t(b));
}

inline subflags operator & (subflags a, subflags b) {
  return subflags(cloudabi_subflags_t(a) & cloudabi_subflags_t(b));
}

inline subflags operator ~ (subflags v) {
  return subflags(~cloudabi_subflags_t(v));
}

enum class subrwflags : cloudabi_subrwflags_t {
  none = 0,
  poll = CLOUDABI_SUBSCRIPTION_FD_READWRITE_POLL,
};

inline subrwflags operator | (subrwflags a, subrwflags b) {
  return subrwflags(cloudabi_subrwflags_t(a) | cloudabi_subrwflags_t(b));
}

inline subrwflags operator & (subrwflags a, subrwflags b) {
  return subrwflags(cloudabi_subrwflags_t(a) & cloudabi_subrwflags_t(b));
}

inline subrwflags operator ~ (subrwflags v) {
  return subrwflags(~cloudabi_subrwflags_t(v));
}

enum class tid : cloudabi_tid_t {};

using timestamp = cloudabi_timestamp_t;

enum class ulflags : cloudabi_ulflags_t {
  none      = 0,
  removedir = CLOUDABI_UNLINK_REMOVEDIR,
};

inline ulflags operator | (ulflags a, ulflags b) {
  return ulflags(cloudabi_ulflags_t(a) | cloudabi_ulflags_t(b));
}

inline ulflags operator & (ulflags a, ulflags b) {
  return ulflags(cloudabi_ulflags_t(a) & cloudabi_ulflags_t(b));
}

inline ulflags operator ~ (ulflags v) {
  return ulflags(~cloudabi_ulflags_t(v));
}

using userdata = cloudabi_userdata_t;

enum class whence : cloudabi_whence_t {
  cur = CLOUDABI_WHENCE_CUR,
  end = CLOUDABI_WHENCE_END,
  set = CLOUDABI_WHENCE_SET,
};

}
}

#endif
