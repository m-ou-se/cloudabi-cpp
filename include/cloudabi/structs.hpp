// Copyright (c) 2016 Nuxi (https://nuxi.nl/) and contributors.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// This file is automatically generated. Do not edit.
//
// Source: https://github.com/NuxiNL/cloudabi

#ifndef CLOUDABI_STRUCTS_HPP
#define CLOUDABI_STRUCTS_HPP

#include <atomic>
#include <cstddef>
#include <cstdint>

#include <mstd/range.hpp>

#include <cloudabi_types.h>

#include "types.hpp"
#include "fd.hpp"
#include "iovec.hpp"

namespace cloudabi {

struct event {
  userdata userdata;
  error error;
  eventtype type;
  union {
    struct {
      cloudabi::userdata identifier;
    } clock;
    struct {
      std::atomic<condvar> *condvar;
    } condvar;
    struct {
      filesize nbytes;
      fd fd;
      eventrwflags flags;
    } fd_readwrite;
    struct {
      std::atomic<lock> *lock;
    } lock;
    struct {
      fd fd;
      signal signal;
      exitcode exitcode;
    } proc_terminate;
  };
};
static_assert(sizeof(event) == sizeof(cloudabi_event_t), "");
static_assert(alignof(event) == alignof(cloudabi_event_t), "");
static_assert(offsetof(event, userdata) == offsetof(cloudabi_event_t, userdata), "");
static_assert(offsetof(event, error) == offsetof(cloudabi_event_t, error), "");
static_assert(offsetof(event, type) == offsetof(cloudabi_event_t, type), "");
static_assert(offsetof(event, clock.identifier) == offsetof(cloudabi_event_t, clock.identifier), "");
static_assert(offsetof(event, condvar.condvar) == offsetof(cloudabi_event_t, condvar.condvar), "");
static_assert(offsetof(event, fd_readwrite.nbytes) == offsetof(cloudabi_event_t, fd_readwrite.nbytes), "");
static_assert(offsetof(event, fd_readwrite.fd) == offsetof(cloudabi_event_t, fd_readwrite.fd), "");
static_assert(offsetof(event, fd_readwrite.flags) == offsetof(cloudabi_event_t, fd_readwrite.flags), "");
static_assert(offsetof(event, lock.lock) == offsetof(cloudabi_event_t, lock.lock), "");
static_assert(offsetof(event, proc_terminate.fd) == offsetof(cloudabi_event_t, proc_terminate.fd), "");
static_assert(offsetof(event, proc_terminate.signal) == offsetof(cloudabi_event_t, proc_terminate.signal), "");
static_assert(offsetof(event, proc_terminate.exitcode) == offsetof(cloudabi_event_t, proc_terminate.exitcode), "");

struct fdstat {
  filetype fs_filetype;
  fdflags fs_flags;
  rights fs_rights_base;
  rights fs_rights_inheriting;
};
static_assert(sizeof(fdstat) == sizeof(cloudabi_fdstat_t), "");
static_assert(alignof(fdstat) == alignof(cloudabi_fdstat_t), "");
static_assert(offsetof(fdstat, fs_filetype) == offsetof(cloudabi_fdstat_t, fs_filetype), "");
static_assert(offsetof(fdstat, fs_flags) == offsetof(cloudabi_fdstat_t, fs_flags), "");
static_assert(offsetof(fdstat, fs_rights_base) == offsetof(cloudabi_fdstat_t, fs_rights_base), "");
static_assert(offsetof(fdstat, fs_rights_inheriting) == offsetof(cloudabi_fdstat_t, fs_rights_inheriting), "");

struct filestat {
  device st_dev;
  inode st_ino;
  filetype st_filetype;
  linkcount st_nlink;
  filesize st_size;
  timestamp st_atim;
  timestamp st_mtim;
  timestamp st_ctim;
};
static_assert(sizeof(filestat) == sizeof(cloudabi_filestat_t), "");
static_assert(alignof(filestat) == alignof(cloudabi_filestat_t), "");
static_assert(offsetof(filestat, st_dev) == offsetof(cloudabi_filestat_t, st_dev), "");
static_assert(offsetof(filestat, st_ino) == offsetof(cloudabi_filestat_t, st_ino), "");
static_assert(offsetof(filestat, st_filetype) == offsetof(cloudabi_filestat_t, st_filetype), "");
static_assert(offsetof(filestat, st_nlink) == offsetof(cloudabi_filestat_t, st_nlink), "");
static_assert(offsetof(filestat, st_size) == offsetof(cloudabi_filestat_t, st_size), "");
static_assert(offsetof(filestat, st_atim) == offsetof(cloudabi_filestat_t, st_atim), "");
static_assert(offsetof(filestat, st_mtim) == offsetof(cloudabi_filestat_t, st_mtim), "");
static_assert(offsetof(filestat, st_ctim) == offsetof(cloudabi_filestat_t, st_ctim), "");

struct recv_in {
  mstd::range<iovec const> ri_data;
  mstd::range<fd> ri_fds;
  msgflags ri_flags;
};
static_assert(sizeof(recv_in) == sizeof(cloudabi_recv_in_t), "");
static_assert(alignof(recv_in) == alignof(cloudabi_recv_in_t), "");
static_assert(offsetof(recv_in, ri_data) == offsetof(cloudabi_recv_in_t, ri_data), "");
static_assert(offsetof(recv_in, ri_fds) == offsetof(cloudabi_recv_in_t, ri_fds), "");
static_assert(offsetof(recv_in, ri_flags) == offsetof(cloudabi_recv_in_t, ri_flags), "");

struct send_in {
  mstd::range<ciovec const> si_data;
  mstd::range<fd const> si_fds;
  msgflags si_flags;
};
static_assert(sizeof(send_in) == sizeof(cloudabi_send_in_t), "");
static_assert(alignof(send_in) == alignof(cloudabi_send_in_t), "");
static_assert(offsetof(send_in, si_data) == offsetof(cloudabi_send_in_t, si_data), "");
static_assert(offsetof(send_in, si_fds) == offsetof(cloudabi_send_in_t, si_fds), "");
static_assert(offsetof(send_in, si_flags) == offsetof(cloudabi_send_in_t, si_flags), "");

struct send_out {
  std::size_t so_datalen;
};
static_assert(sizeof(send_out) == sizeof(cloudabi_send_out_t), "");
static_assert(alignof(send_out) == alignof(cloudabi_send_out_t), "");
static_assert(offsetof(send_out, so_datalen) == offsetof(cloudabi_send_out_t, so_datalen), "");

struct sockaddr {
  sa_family sa_family;
  union {
    struct {
      std::uint8_t addr[4];
      std::uint16_t port;
    } sa_inet;
    struct {
      std::uint8_t addr[16];
      std::uint16_t port;
    } sa_inet6;
  };
};
static_assert(sizeof(sockaddr) == sizeof(cloudabi_sockaddr_t), "");
static_assert(alignof(sockaddr) == alignof(cloudabi_sockaddr_t), "");
static_assert(offsetof(sockaddr, sa_family) == offsetof(cloudabi_sockaddr_t, sa_family), "");
static_assert(offsetof(sockaddr, sa_inet.addr) == offsetof(cloudabi_sockaddr_t, sa_inet.addr), "");
static_assert(offsetof(sockaddr, sa_inet.port) == offsetof(cloudabi_sockaddr_t, sa_inet.port), "");
static_assert(offsetof(sockaddr, sa_inet6.addr) == offsetof(cloudabi_sockaddr_t, sa_inet6.addr), "");
static_assert(offsetof(sockaddr, sa_inet6.port) == offsetof(cloudabi_sockaddr_t, sa_inet6.port), "");

struct sockstat {
  sockaddr ss_sockname;
  sockaddr ss_peername;
  error ss_error;
  sstate ss_state;
};
static_assert(sizeof(sockstat) == sizeof(cloudabi_sockstat_t), "");
static_assert(alignof(sockstat) == alignof(cloudabi_sockstat_t), "");
static_assert(offsetof(sockstat, ss_sockname) == offsetof(cloudabi_sockstat_t, ss_sockname), "");
static_assert(offsetof(sockstat, ss_peername) == offsetof(cloudabi_sockstat_t, ss_peername), "");
static_assert(offsetof(sockstat, ss_error) == offsetof(cloudabi_sockstat_t, ss_error), "");
static_assert(offsetof(sockstat, ss_state) == offsetof(cloudabi_sockstat_t, ss_state), "");

struct subscription {
  userdata userdata;
  subflags flags;
  eventtype type;
  union {
    struct {
      cloudabi::userdata identifier;
      clockid clock_id;
      timestamp timeout;
      timestamp precision;
      subclockflags flags;
    } clock;
    struct {
      std::atomic<condvar> *condvar;
      std::atomic<lock> *lock;
      scope condvar_scope;
      scope lock_scope;
    } condvar;
    struct {
      fd fd;
      subrwflags flags;
    } fd_readwrite;
    struct {
      std::atomic<lock> *lock;
      scope lock_scope;
    } lock;
    struct {
      fd fd;
    } proc_terminate;
  };
};
static_assert(sizeof(subscription) == sizeof(cloudabi_subscription_t), "");
static_assert(alignof(subscription) == alignof(cloudabi_subscription_t), "");
static_assert(offsetof(subscription, userdata) == offsetof(cloudabi_subscription_t, userdata), "");
static_assert(offsetof(subscription, flags) == offsetof(cloudabi_subscription_t, flags), "");
static_assert(offsetof(subscription, type) == offsetof(cloudabi_subscription_t, type), "");
static_assert(offsetof(subscription, clock.identifier) == offsetof(cloudabi_subscription_t, clock.identifier), "");
static_assert(offsetof(subscription, clock.clock_id) == offsetof(cloudabi_subscription_t, clock.clock_id), "");
static_assert(offsetof(subscription, clock.timeout) == offsetof(cloudabi_subscription_t, clock.timeout), "");
static_assert(offsetof(subscription, clock.precision) == offsetof(cloudabi_subscription_t, clock.precision), "");
static_assert(offsetof(subscription, clock.flags) == offsetof(cloudabi_subscription_t, clock.flags), "");
static_assert(offsetof(subscription, condvar.condvar) == offsetof(cloudabi_subscription_t, condvar.condvar), "");
static_assert(offsetof(subscription, condvar.lock) == offsetof(cloudabi_subscription_t, condvar.lock), "");
static_assert(offsetof(subscription, condvar.condvar_scope) == offsetof(cloudabi_subscription_t, condvar.condvar_scope), "");
static_assert(offsetof(subscription, condvar.lock_scope) == offsetof(cloudabi_subscription_t, condvar.lock_scope), "");
static_assert(offsetof(subscription, fd_readwrite.fd) == offsetof(cloudabi_subscription_t, fd_readwrite.fd), "");
static_assert(offsetof(subscription, fd_readwrite.flags) == offsetof(cloudabi_subscription_t, fd_readwrite.flags), "");
static_assert(offsetof(subscription, lock.lock) == offsetof(cloudabi_subscription_t, lock.lock), "");
static_assert(offsetof(subscription, lock.lock_scope) == offsetof(cloudabi_subscription_t, lock.lock_scope), "");
static_assert(offsetof(subscription, proc_terminate.fd) == offsetof(cloudabi_subscription_t, proc_terminate.fd), "");

struct recv_out {
  std::size_t ro_datalen;
  std::size_t ro_fdslen;
  sockaddr ro_sockname;
  sockaddr ro_peername;
  msgflags ro_flags;
};
static_assert(sizeof(recv_out) == sizeof(cloudabi_recv_out_t), "");
static_assert(alignof(recv_out) == alignof(cloudabi_recv_out_t), "");
static_assert(offsetof(recv_out, ro_datalen) == offsetof(cloudabi_recv_out_t, ro_datalen), "");
static_assert(offsetof(recv_out, ro_fdslen) == offsetof(cloudabi_recv_out_t, ro_fdslen), "");
static_assert(offsetof(recv_out, ro_sockname) == offsetof(cloudabi_recv_out_t, ro_sockname), "");
static_assert(offsetof(recv_out, ro_peername) == offsetof(cloudabi_recv_out_t, ro_peername), "");
static_assert(offsetof(recv_out, ro_flags) == offsetof(cloudabi_recv_out_t, ro_flags), "");

}

#endif
